can you please fix spelling, grammar, and style as well as add punctutation where necessary and add paragraph by adding two line breaks between paragraphs? please output nothing but the response and add the result in three ticks like ```this``` 
this is part one of ??? 


I'm Matt ston I'm an architect at Microsoft and I'm also the lead designer of CP uh and I'm Dustin Campbell I'm an architect um on net tooling and also a member of the C language design team and work a lot with this guy yeah so we um uh we have doet coming out today net 9 and that also means that we have C 13 C 13 um meeting the world today and we're here to tell you a little about what's in this version of c um we uh want to start by taking you on a very brief tour of how you can stay updated on what's going on with C like everything else here it's open source yeah so I've got a couple of things up here on my laptop um that should show so so just a couple of ways that if you're new to the c universe or you want to get involved or stay engaged we have a few examples of ways to do that at kind of various levels of Interest right um this first thing this is learn. microsoft.com this is the what's new in C 13 so if you want to just find out what's uh what's in the product for C 13 and get documentation on these things and how they kind of play in there's all all of it is here and uh um this is kind of a great way to kind of kind of just get an overview of the languages that have shipped right that is true um however language features that have shipped yeah the features the um um as we go like the the C 14 cycle essentially starts now and as we go we tend to put language features out in in preview um and we actually have one that we'll be showing today that's already going to be in preview um and we we try to keep the what's new page updated even with um preview documentation of preview features as well so it is a good place to keep an eye on c as it evolves over the year um if you want to um another spot you can look at and uh and this is on the uh on GitHub in the rosin repo which is where the the C and Visual Basic compilers and IDE Stacks uh all the code lives and where they're in active development and this is the the language feature status page it's in the docs folder um where you can see the nitty-gritty on like who's working on what and uh what we're looking at for you know C 13 and then also kind of what's happening for for next and if you would if you if you're interested in seeing branches merge this is where to go right uh so it's kind of a yeah yeah the working state is really everything that we currently have engineering activity on like somebody's building um as a c language design team we work on even more things that haven't yet kind of started being implemented um and so the place to go if you really want to engage with the uh C design is that we have have separate Repro C Lang for um for the language design itself of c and this is again it's in the net uhet foundation on and on on GitHub and uh it is um this is where notes from our language design meetings are posted this is where proposals are posted there's um issues and discussions and we're actually you know this is also an active development though it's not necessarily the code development but it's where kind of the the nitty-gritty of the the language design itself happens so if you want to get involved in some way or engage with that provide feedback discuss with you know the team or you know and other you know like-minded you know folks uh then this is the place to go for that yeah and there is quite a a lot of community contribution in this repo as well to the design of C as opposed to the implementation we saw before absolutely but I guess we're here to look at code yeah let's talk about um many of the like there's a long list of of features in C 13 um and by the quotation marks I mean that some of them really feel like just bug fixes we're going to show some of the some of the more interesting ones um but as you could see on that um language status page and and the W's new um there's there's plenty yeah there is plenty um and and in a way I mean we've been kind of looking at the features that did land in C 13 and it feels very much like you know in a way um almost not necessarily small features but features that might feel smaller but they are there to just make genuinely the cons consumption of code just better easier make sure you're doing the right things you know and you know putting you on the right path giving type authors and Library authors the right tools they need to help you get on the right path as a you know for consuming apis yeah so it's it's kind of there is kind of like a theme to it even though it kind of feels a little grab baggy but I like yeah I like this idea that it's very it's very light on new syntax but there's a lot of semantics sort of behind familiar syntax if you want yeah yeah um starting with this one here we pams yes this has been uh this has been in the language since C 10 yeah pams has been around forever and it's always been about arrays right so you can have pams array and that means that that call up there on the first line um you know you you all know this just uh packages all the arguments um for that parameter into an array that gets created on the spot and passed on to uh to the method um and almost immediately after this shipped we're like why couldn't we do you know pams I inumerable and then net 2 came out c 2 with generics and they're like well why can't I do one with prams i inumerable t of te yeah um and uh that's that's been a maybe the oldest ass you know a lot way to be clear and you may want to show this like it the thing you pretty much have to do and have had to do in tar since c 2 if you want to have a general API that takes all kinds of collections but also is params is you need two overloads the general one that takes I of T and then an array one that is params because only arrays can be params you can kind of you can kind of guess where we going out there um this gives you the way to kind of like have something you can if you've got a list in hand you can pass that and it will be it it will get you know make its way into the I inumerable of T and then in the other one you can pass a list of arguments and they'll get into the prams and often you know this is kind of implemented funny you wouldn't normally do this you usually you take the prams one and you you'd use that to call the I one but it seems like every API that wants to expose prams ends up doing something like this as well yeah um and we've we've sort of had it on our list for well over a decade to do something about that but then there's like well if we do PM iable then what about other people will immediately be like okay perams other things right and so we we kind of left it alone uh but last year when we were releasing C 12 a very consequential feature came out which was uh collection Expressions my favorite feature in years right so to be able to surround this with brackets and just say this is now a collection that is not opinion exactly opinionated on the type of that collection instead it gets it decides what the collection is going to be what the type of the collection is based on its surroundings right essentially so in this case it would be we could uh uh this is a way that you could also pass it in here and and get a um you know like and it looks like very similar to passing per amps right you know but really close with just these square brackets yeah but but the big difference with collection Expressions is that you can and some of you might not have picked them up yet please do they're awesome is that you can pass collection Expressions to almost any collection type right um there are standard ways that they will work they will work like oldfashioned collection Expressions if or collection initializers rather if you don't do anything else but you can also um set things up in your API to to tell it what to do to create your collection in a smart way and and the compiler special Cas is a lot of common types and so and it's really smart it can create from the same syntactic expression it can create all kinds of different Collections and it'll do it'll do a really good job at creating um efficient implementations of interfaces and that kind of stuff now in this case overload resolution is going to make it so it calls the array still but if I delete that and I can delete that now because I've got that collection expression up there it will produce the compiler will generate a type that's very very efficient that implements ion numerable for you so you don't have to go and say I'm newing up a list or I'm neing up something else um to pass in here but instead it will new up something that Implements iable of te um so that it can be pass here successfully and efficiently and so that little extra step we took in t shap 13 is okay now we have Machinery to create all kinds of different collections from elements from a list of elements couldn't we just do that with pams as well could we just allow pams on all those collection types and have it do the same thing and it turns out we can um and so this of course is legal in C 13 we have prams for all sorts of things um and basically aot essentially the things that you can create with collection Expressions um because we know how to build that Machinery now so if I delete these brackets it works just fine and it's going to do essentially the same thing under the hood as if you passed in a collection expression beautiful you can pretty much think about it as pams is just the compiler putting those square brackets around the elements that you're listing yeah as arguments right so it's um it those two features are very closely connected absolutely now in this case because it's I inumerable we're going to be allocating something on the hood under you know under the hood to do this um but and there are cases where you don't want that right and so you might uh wonder what other things we could do with perams um and you know if I wanted to do something a little bit more efficient using some of the span based types that we have that's also allowed right so I could type you know Span in here that works or I could use its you know readon cousin um um to pass in you know arguments that are you know essentially could be from some some hpe allocated type it could be from an array or they could even just be allocated on the stack this could point a memory on the stack so that you're not making any objects to pass something in that can then be for eached over like this it's actually and this is like probably the the the second longest request we've had for for pams is for the span types um because the compiler can choose to allocate that span on the stack right and when and when it does you know no no memories wasted and it's actually very similar to if you had had all those parameters individually in your signature they would also have gone on the stack so this is this is a thing that sort of from a memory layout performance perspective mirrors uh multiple parameters the best and there's another piece of this that I think is really interesting which is that you know overload resolution would like to say that in this case you know read only SP is a better overload because it would Implement ion numer oft but of course it it doesn't it can't and so um it's a it's a it's a it's a restruck it can't do that and uh I Ru is not suitable but still we end up picking the readon span type here and this is part of another feature of C 13 that is kind of like you know you know sort of I would say kind of one of those things it's really under the hood you won't see it you know pop up but it will help you do the right thing yeah so we we we essentially embarked on a new story arc if you will in C for um for for spans that is first class spans like even though um spans have been around now for a long time um I mean a lot of people they have weird restrictions and so on because they have to live on the stack and so so a lot of people don't use them directly but we want to make it so that you can get a lot of benefit uh from them without having to understand too much of that machinery and so but but the language itself has kind of kept them at arms length for a bit like there are conversions from array to span to readon span but they're not in the language they've been used to define conversions on the span types and so on and that means spans haven't felt fully integrated in the language um but we have started down and there'll be more in C 14 making spans first class and the the the sort of down payment on that in C 13 that you see here is that we make spans better than arrays and all the interfaces implemented by arrays in overload resolution right I mean it is the more efficient way generally of doing that and so it makes sense um all right so another thing about pams about prams collections as we said you know we can do an i inumerable okay we can do read only span but we can do lots of other types and so there are also ways with collection Expressions to you know expose them to uh collection expressions in such a way that they they can the collection Expressions knows how to build them um one of the types that's been kind of uh challenging um I think I even showed an analyzer on this years ago in a what's new on c talk but the idea that like a mutable array is a is one of those types that we use a lot but we especially use a lot but it can't be used with the old style collection initializer





I'm Matt Ston. I'm an architect at Microsoft, and I'm also the lead designer of CP. 

Uh, I'm Dustin Campbell. I'm an architect on .NET tooling and also a member of the C language design team. I work a lot with this guy. 

Today, we have .NET 9 coming out, which also means that we have C# 13 meeting the world today. We're here to tell you a little about what's in this version of C#. We want to start by taking you on a very brief tour of how you can stay updated on what's going on with C#. Like everything else here, it's open source. 

I've got a couple of things up here on my laptop that should show you a few ways to get involved or stay engaged if you're new to the C# universe. We have a few examples of ways to do that at various levels of interest. 

This first thing is learn.microsoft.com, which has the "What's New in C# 13." If you want to find out what's in the product for C# 13 and get documentation on these features and how they play in, all of it is here. This is a great way to get an overview of the languages that have shipped. 

However, language features that have shipped are just the beginning. As we go, the C# 14 cycle essentially starts now, and we tend to put language features out in preview. We actually have one that we'll be showing today that's already going to be in preview. We try to keep the "What's New" page updated, even with preview documentation of preview features, so it is a good place to keep an eye on C# as it evolves over the year. 

Another spot you can look at is on GitHub in the Roslyn repo, which is where the C# and Visual Basic compilers and IDE stacks live. This is the language feature status page in the docs folder, where you can see the nitty-gritty on who's working on what and what we're looking at for C# 13, as well as what's happening next. If you're interested in seeing branches merge, this is where to go. 

The working state is everything that we currently have engineering activity on. As the C# language design team, we work on even more things that haven't yet started being implemented. The place to go if you really want to engage with the C# design is our separate repo, C# Lang, which is again in the .NET Foundation on GitHub. This is where notes from our language design meetings are posted, where proposals are made, and where issues and discussions happen. This is also an active development area, though it's not necessarily code development; it's where the nitty-gritty of the language design itself occurs. If you want to get involved in some way, provide feedback, or discuss with the team or other like-minded folks, then this is the place to go for that. 

There is quite a lot of community contribution in this repo as well, particularly regarding the design of C# as opposed to the implementation we saw before. 

Absolutely, but I guess we're here to look at code. Let's talk about many of the features in C# 13. By "features," I mean that some of them really feel like just bug fixes. We're going to show some of the more interesting ones, but as you can see on that language status page and the "What's New," there's plenty. 

In a way, we've been looking at the features that landed in C# 13, and it feels very much like, almost not necessarily small features, but features that might feel smaller. They are there to genuinely improve the consumption of code, making it easier and ensuring you're doing the right things. They provide type authors and library authors with the right tools they need to help you get on the right path for consuming APIs. 

There is a theme to it, even though it feels a little grab-baggy. I like the idea that it's very light on new syntax, but there's a lot of semantics behind familiar syntax. 

Starting with this one here: params. Yes, this has been in the language since C# 10. Params has been around forever, and it's always been about arrays. You can have a params array, which means that the call up there on the first line packages all the arguments for that parameter into an array that gets created on the spot and passed on to the method. 

Almost immediately after this shipped, we wondered why we couldn't do params with IEnumerable. Then .NET 2 came out with generics, and we thought, "Well, why can't I do one with params IEnumerable<T>?" That's been a long-standing request. 

To be clear, if you want to have a general API that takes all kinds of collections but also uses params, you need two overloads: the general one that takes IEnumerable<T> and then an array one that is params because only arrays can be params. You can kind of guess where we're going with this. 

This gives you

the ability to have something where, if you've got a list in hand, you can pass that, and it will make its way into the IEnumerable<T>. In the other overload, you can pass a list of arguments, and they'll get into the params. Often, this is implemented in a way that you wouldn't normally do; you usually take the params one and use that to call the IEnumerable<T> one. However, it seems like every API that wants to expose params ends up doing something like this as well. 

We've had it on our list for well over a decade to do something about that. But then there's the question: if we do params for IEnumerable, what about other types? People will immediately be like, "Okay, params for other things, right?" So we kind of left it alone. 

Last year, when we were releasing C# 12, a very consequential feature came out: collection expressions. My favorite feature in years! To be able to surround this with brackets and just say this is now a collection that is not opinionated on the type of that collection is a game changer. It decides what the collection is going to be based on its surroundings. 

In this case, we could pass it in here and get a result that looks very similar to passing params, but with just these square brackets. The big difference with collection expressions is that you can pass them to almost any collection type. There are standard ways that they will work, and they will function like old-fashioned collection initializers if you don't do anything else. However, you can also set things up in your API to tell it how to create your collection in a smart way. 

The compiler specializes in a lot of common types, and it can create all kinds of different collections from the same syntactic expression. It does a really good job at creating efficient implementations of interfaces and that kind of stuff. 

Now, in this case, overload resolution will make it so it calls the array still. But if I delete that, I can do so now because I've got that collection expression up there. The compiler will generate a type that's very efficient and implements IEnumerable<T> for you, so you don't have to go and say, "I'm newing up a list" or "I'm newing up something else" to pass in here. Instead, it will create something that implements IEnumerable<T> so that it can be passed here successfully and efficiently. 

That little extra step we took in C# 13 is that now we have machinery to create all kinds of different collections from a list of elements. Couldn't we just do that with params as well? Could we allow params on all those collection types and have it do the same thing? It turns out we can! 

So, this is, of course, legal in C# 13. We have params for all sorts of things, essentially for the things that you can create with collection expressions. We know how to build that machinery now, so if I delete these brackets, it works just fine, and it's going to do essentially the same thing under the hood as if you passed in a collection expression. 

You can think about it as params being the compiler putting those square brackets around the elements that you're listing as arguments. Those two features are very closely connected. 

In this case, because it's IEnumerable<T>, we're going to be allocating something under the hood. There are cases where you don't want that, and you might wonder what other things we could do with params. If I wanted to do something a little more efficient using some of the span-based types that we have, that's also allowed. 

I could type Span<T> in here, and that works. Or I could use its read-only cousin to pass in arguments that could be from some heap-allocated type, from an array, or even just allocated on the stack. This could point to memory on the stack, so that you're not making any objects to pass something in that can then be iterated over like this. 

This is probably the second longest request we've had for params: support for span types. The compiler can choose to allocate that span on the stack, and when it does, no memory is wasted. It's actually very similar to if you had all those parameters individually in your signature; they would also have gone on the stack. 

From a memory layout and performance perspective, this mirrors multiple parameters the best. There's another piece of this that I think is really interesting: overload resolution would like to say that in this case, ReadOnlySpan<T> is a better overload because it would implement IEnumerable<T>. However, it can't, and so we end up picking the ReadOnlySpan<T> type here. 

This is part of another feature of C# 13 that is somewhat under the hood. You won't see it pop up, but it will help you do the right thing. We essentially embarked on a new story arc, if you will, in C# for spansâ€”making spans first-class citizens. 

Even though spans have been around for a long time, many people find them challenging due to their restrictions, as they have to live on the stack. As a result, a lot of developers don't use them directly. We want to make it so that you can get a lot of benefits from spans without having to understand too much of that machinery. 

However, the language itself has kept spans at arm's length for a bit. There are conversions from arrays to spans to ReadOnlySpans, but they haven't been fully integrated into the language. This means spans haven't felt completely integrated into the language. 

We have started down this path, and there will be more in C# 14 to make spans first-class citizens. The down payment on that in C# 13 is that we make spans better than arrays in all the interfaces implemented by arrays in overload resolution. It is generally a more efficient way of doing things, and it makes sense. 

Another thing about params and collections is that we can do IEnumerable<T> and ReadOnlySpan<T>, but we can also work with many other types. There are ways with collection expressions to expose them in such a way that the collection expressions know how to build them. 

One of the types that has been challenging is the mutable array. I even showed an analyzer on this years ago in a "What's New in C#" talk. The idea is that a mutable array is one of those types we use a lot, but it can't be used with the old-style collection initializer. 

This has been a long-standing limitation, and we are looking to address it. The goal is to make it easier for developers to work with mutable arrays in a way that feels natural and integrated into the language. 

As we continue to evolve C#, we are committed to listening to the community and addressing these long-standing requests. We want to ensure that the language remains powerful, flexible, and easy to use for all developers. 

In summary, C# 13 introduces several exciting features that enhance the language's usability and performance. From improved support for params and spans to the introduction of collection expressions, we are making strides toward a more efficient and developer-friendly experience. 

We encourage everyone to explore these new features and provide feedback as we continue to refine and improve the language. Thank you for joining us today, and we look forward to seeing how you leverage these new capabilities in your projects!
